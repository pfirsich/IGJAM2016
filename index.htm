<!DOCTYPE html>
<html lang="en">
	<head>
		<title>sadness</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

		<script src="three.js"></script>

		<script src="js/ImprovedNoise.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/threex.keyboardstate.js"></script>

		<script>

			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;

			var camera, controls, scene, renderer;

			var player;
			var maxBullets = 2500, nextBulletIndex = 0, bullets = new Array(maxBullets);
			var bulletGeometry = new THREE.BoxGeometry(40, 40, 100);
			var bulletMaterial = new THREE.MeshPhongMaterial( {
					color: 0xffff00,
					emissive: 0xffff00,
					shading: THREE.FlatShading
				});
			var trailMaterial = new THREE.MeshBasicMaterial( {
					color: 0x156289,
					emissive: 0x072534,
				});

			var crosshairMeshNear, crosshairMeshFar;

			var terrain, light;

			var worldWidth = 256, worldDepth = 256,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var clock = new THREE.Clock();

			var keyboard = new THREEx.KeyboardState();

			var sunDir = new THREE.Vector3(0.6, 1, 0.6);
			sunDir.normalize();

			var texLoader = new THREE.TextureLoader();

			function Terrain(width, height, widthSegments, heightSegments) {
				this.width = width;
				this.height = height;
				this.widthSegments = widthSegments;
				this.heightSegments = heightSegments;
				this.dataToUnitConversion = 60;

				this.data = this.generateHeight(widthSegments + 1, heightSegments + 1);

				this.geometry = new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments);
				this.geometry.rotateX( - Math.PI / 2 );
				var vertices = this.geometry.attributes.position.array;
				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
					vertices[j + 1] = this.data[i] * this.dataToUnitConversion;
				}
				this.geometry.computeFaceNormals();
				this.geometry.computeVertexNormals();

				this.material = new THREE.MeshLambertMaterial({
					color: 0xe68a00,
					shading: THREE.SmoothShading
				});
				this.mesh = new THREE.Mesh(this.geometry, this.material);
				this.mesh.castShadow = true;
				this.mesh.receiveShadow = true;
			}

			Terrain.prototype.generateHeight = function(width, height) {
				var size = width * height, data = new Uint8Array( size ),
				perlin = new ImprovedNoise(), quality = 50, z = Math.random() * 100;
				var qualities = [{freq: 50, amp: 0.85, negativeExp: 0.5}, {freq: 20, amp: 0.15, negativeExp: 1.0}];

				for (var j = 0; j < qualities.length; j++) {
					for (var i = 0; i < size; i++) {
						var x = i % width, y = ~~ (i / width);
						var noise = perlin.noise(x / qualities[j].freq, y / qualities[j].freq, z);
						if (noise < 0.0) noise = -Math.pow(-noise, qualities[j].negativeExp);
						noise = (noise + 1.0) * 0.5;
						data[i] += noise * qualities[j].amp * 255;
					}
				}

				return data;
			}

			Terrain.prototype.getHeight = function(x, y) {
				// half is center
				var x = worldHalfWidth + Math.floor(x / this.width * this.widthSegments);
				x = Math.min(Math.max(x, 0), this.widthSegments);
				var y = worldHalfDepth + Math.floor(y / this.height * this.heightSegments);
				y = Math.min(Math.max(y, 0), this.heightSegments);
				return this.data[x + y * worldWidth] * this.dataToUnitConversion;
			}

			function Input(stateCallback) {
				this.stateCallback = stateCallback;
				this.state = 0;
			}

			Input.prototype.update = function() {
				this.lastState = this.state;
				this.state = this.stateCallback();
				this.pressed = this.state > this.lastState;
				this.released = this.state < this.lastState;
			}

			Input.getAxisInputFromKeyboard = function(positive, negative) {
				return new Input(function() {return (keyboard.pressed(positive) ? 1.0 : 0.0) - (keyboard.pressed(negative) ? 1.0 : 0.0)});
			}

			function KeyboardController(left, right, up, down) {
				this.moveX = Input.getAxisInputFromKeyboard(left, right);
				this.moveY = Input.getAxisInputFromKeyboard(up, down);
				this.shoot = new Input(function() {return keyboard.pressed("a") ? 1.0 : 0.0});
			}

			KeyboardController.prototype.update = function() {
				this.moveX.update();
				this.moveY.update();
				this.shoot.update();
			}

			function alignAlongVector(mesh, vec) {
				var dir = vec.clone();
				dir.normalize();
				var worldUp = new THREE.Vector3(0, 1, 0);

				var right = new THREE.Vector3();
				right.crossVectors(dir, worldUp);

				var up = new THREE.Vector3();
				up.crossVectors(dir, right);

				var rotMat = new THREE.Matrix4().makeBasis(right, up, dir);
				var rotQuat = new THREE.Quaternion().setFromRotationMatrix(rotMat);
				rotQuat.normalize();

				mesh.setRotationFromQuaternion(rotQuat);

				return rotMat;
			}

			function spawnBullet(position, direction, material, stand) {
				var bullet = new Object();
				bullet.lifetime = 500.0;
				bullet.velocity = direction.clone();
				bullet.velocity.normalize();
				if (stand == true) {
					bullet.velocity.set(0, 0, 0);
				}
				bullet.velocity.multiplyScalar(50000.0);
				bullet.mesh = new THREE.Mesh(bulletGeometry, material);
				scene.add(bullet.mesh);
				bullet.mesh.castShadow = true;
				bullet.mesh.position.copy(position);
				alignAlongVector(bullet.mesh, direction);
				bullet.alive = true;
				bullets[nextBulletIndex] = bullet;
				nextBulletIndex++;
				if(nextBulletIndex >= maxBullets) nextBulletIndex = 0;
			}

			function updateBullets(dt) {
				for (var i = 0; i < maxBullets; ++i) {
					var bullet = bullets[i];
					if (bullet != undefined && bullet.alive) {
						bullet.lifetime -= dt;
						if (bullet.lifetime <= 0) {
							bullet.alive = false;
							scene.remove(bullet.mesh);
						} else {
							var deltaPos = bullet.velocity.clone();
							deltaPos.multiplyScalar(dt);
							bullet.mesh.position.add(deltaPos);

							// check collisions
						}
					}
				}
			}

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );
				hudCamera = new THREE.OrthographicCamera(0, window.innerWidth, 0, window.innerHeight, -1, 1);

				scene = new THREE.Scene();
				hudScene = new THREE.Scene();

				terrain = new Terrain(30000, 30000, worldWidth - 1, worldDepth - 1);
				scene.add(terrain.mesh);

				player = new Object();

				player.geometry = new THREE.BoxGeometry(200, 200, 200);
				player.material = new THREE.MeshPhongMaterial( {
					color: 0x156289,
					emissive: 0x072534,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				} );
				player.mesh = new THREE.Mesh(player.geometry, player.material);
				player.mesh.castShadow = true;
				player.mesh.receiveShadow = true;
				player.velocity = new THREE.Vector3(0.0, 0.0, -1.0);
				player.speed = 2000.0;
				player.radius = 100.0;
				player.accel = player.speed * 1.5;
				player.cameraMinDistance = player.radius * 7.0;
				player.cameraDistance = player.radius * 10.0;
				player.cameraApproachSpeed = 1.0;
				player.focusPointDistance = player.speed;
				player.focusPointMaxDistance = player.speed * 10.0;
				player.velocity.multiplyScalar(player.speed);
				player.nextShot = clock.getElapsedTime();
				player.shotInterval = 0.15;
				player.nextTrail = clock.getElapsedTime();
				player.trailInterval = 0.15;
				player.cameraModifier = 0.0;
				scene.add(player.mesh);

				player.controller = new KeyboardController("left", "right", "up", "down");

				player.mesh.position.y = terrain.getHeight(0, 0) + 100;

				light = new THREE.DirectionalLight(0xffe0b3);
				light.castShadow = true;
				var shadowVolumeSize = 2000;
				light.shadow.camera.near = 10;
				light.shadow.camera.far = 20000;
				light.shadow.camera.left = -shadowVolumeSize;
				light.shadow.camera.right = shadowVolumeSize;
				light.shadow.camera.top = shadowVolumeSize;
				light.shadow.camera.bottom = -shadowVolumeSize;
				light.shadow.mapWidth = 8192;
				light.shadow.mapHeight = 8192;
				scene.add(light);

				scene.add(new THREE.CameraHelper(light.shadow.camera));

				camera.position.x = 0;
				camera.position.z = 1000;
				camera.position.y = terrain.getHeight(camera.position.x, camera.position.z) + 500;
				camera.lookAt(player.mesh.position);
				camera.terrainOffset = 60;
				camera.playerHeightOffset = player.radius;

				// ui scene
				var crosshairMaterial = new THREE.MeshBasicMaterial({
					color: 0x00ff00,
					side: THREE.DoubleSide,
					transparent: true,
					opacity: 0.5,
					map: texLoader.load("crosshair.png")
				});
				var crosshairGeometry = new THREE.PlaneGeometry(50, 50, 1, 1);
				crosshairMeshNear = new THREE.Mesh(crosshairGeometry, crosshairMaterial);
				crosshairMeshFar = new THREE.Mesh(crosshairGeometry, crosshairMaterial);
				crosshairMeshFar.scale.set(0.5, 0.5, 0.5);
				hudScene.add(crosshairMeshNear);
				hudScene.add(crosshairMeshFar);

				renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;

				renderer.shadowMap.enabled = true;
				renderer.shadowMapSoft = true;

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				camera.right = window.innerWidth;
				camera.bottom = window.innerHeight;
				hudCamera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function updatePlayer(dt) {
				player.controller.update();

				var rotMat = alignAlongVector(player.mesh, player.velocity);

				var move = new THREE.Vector3(-player.controller.moveX.state, -player.controller.moveY.state, 0);
				move.multiplyScalar(player.accel);
				move.multiplyScalar(dt);
				move.applyMatrix4(rotMat);

				var terrainHeight = terrain.getHeight(player.mesh.position.x, player.mesh.position.z);
				if (player.mesh.position.y < terrainHeight) {
					player.mesh.position.setY(terrainHeight);
					player.velocity.add(new THREE.Vector3(0, 200, 0));
				}

				player.velocity.add(move);
				player.velocity.setLength(player.speed);

				var velDt = player.velocity.clone();
				velDt.multiplyScalar(dt);
				player.mesh.position = player.mesh.position.add(velDt);

				if (player.controller.shoot.state > 0) {
					if (player.nextShot < clock.getElapsedTime()) {
						player.nextShot = clock.getElapsedTime() + player.shotInterval;
						spawnBullet(player.mesh.position, player.velocity, bulletMaterial, false);
					}
				}

				if (player.nextTrail < clock.getElapsedTime()) {
					player.nextTrail = clock.getElapsedTime() + player.trailInterval;
					spawnBullet(player.mesh.position, player.velocity, trailMaterial, true);
				}

				if (Math.abs(player.controller.moveX.state) > 0.1 || Math.abs(player.controller.moveY.state) > 0.1) {
					player.cameraModifier += dt;
					if (player.cameraModifier > 1.0) player.cameraModifier = 1.0;
				} else {
					player.cameraModifier -= dt;
					if (player.cameraModifier < 0.0) player.cameraModifier = 0.0;
				}
			}

			function lerp(a, b, t) {
				return a * (1 - t) + b * t;
			}

			function updateCamera(dt) {
				var playerVelocity = player.velocity.clone();
				playerVelocity.normalize();
				//var angleDist = Math.pow(Math.max(0, camera.getWorldDirection().dot(playerVelocity)), 40.0);
				angleDist = 1.0 - player.cameraModifier;

				var playerPos = player.mesh.position.clone().add(new THREE.Vector3(0, angleDist * camera.playerHeightOffset, 0));
				var rel = playerPos.sub(camera.position);
				// Adjust target distance
				var targetDistance = lerp(player.cameraMinDistance, player.cameraDistance, angleDist);
				rel.setLength((rel.length() - targetDistance));
				camera.position.add(rel);

				var terrainHeight = terrain.getHeight(camera.position.x, camera.position.z);
				if (camera.position.y < terrainHeight) {
					camera.position.y = terrainHeight + camera.terrainOffset;
				}

				// adjust lookat
				var focusPoint = player.velocity.clone();
				focusPoint.setLength(lerp(player.focusPointMaxDistance, player.focusPointDistance, angleDist));
				focusPoint.add(player.mesh.position);
				camera.lookAt(focusPoint);

				light.target = camera;
				var dir = sunDir.clone();
				dir.multiplyScalar(5000.0);
				light.position.copy(dir.add(light.target.position));
			}

			function projectToScreen(vec, camera) {
				var projected = vec.clone().project(camera);
				projected.multiply(new THREE.Vector3(1, -1, 0));
				projected.add(new THREE.Vector3(1, 1, 0));
				projected.multiply(new THREE.Vector3(window.innerWidth / 2.0, window.innerHeight / 2.0, 0));
				return projected;
			}

			function updateUI(dt) {
				var vel = player.velocity.clone();
				var crosshairDist = player.speed * 1.5;

				var crosshairPos = player.mesh.position.clone().add(vel.setLength(crosshairDist));
				crosshairMeshNear.position.copy(projectToScreen(crosshairPos, camera));

				crosshairPos = player.mesh.position.clone().add(vel.setLength(crosshairDist*3.0));
				crosshairMeshFar.position.copy(projectToScreen(crosshairPos, camera));
			}

			function animate() {
				requestAnimationFrame(animate);

				var dt = clock.getDelta();

				updateBullets(dt);
				updatePlayer(dt);
				updateCamera(dt);
				updateUI(dt);

				render();
				stats.update();
			}

			function render() {
				renderer.clear();
				renderer.render(scene, camera);
				renderer.render(hudScene, hudCamera);
			}

		</script>

	</body>
</html>
