<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Gesichtskirmes // Tron Cruise</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>

		<script src="three.js"></script>
        <script src="howler.core.js"></script>

		<script src="js/ImprovedNoise.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/threex.keyboardstate.js"></script>

		<script>
			if (!Detector.webgl) {
				Detector.addGetWebGLMessage();
				document.getElementById('container').innerHTML = "";
			}

			var container, stats;

			var scene, renderer;

			var maxBullets = 2048, nextBulletIndex = 0, bullets = new Array(maxBullets);
			var bulletGeometry = new THREE.BoxGeometry(40, 40, 150);
			var bulletMaterial = new THREE.MeshPhongMaterial( {
					color: 0xffff00,
					emissive: 0xffff00,
					shading: THREE.FlatShading
				});

			var terrain, light;

			var worldWidth = 256, worldDepth = 256,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var clock = new THREE.Clock();

			var initialized = false;

			var sunDir = new THREE.Vector3(0.6, 1, 0.6);
			sunDir.normalize();

			var texLoader = new THREE.TextureLoader();
			var jsonLoader = new THREE.JSONLoader();

			/*var resourcesToLoad = 0;
			var resourcesLoaded = 0;
			function superLoad(callback, args) {
			    resourcesToLoad += 1;
			    var future = new Object();
			    future.done = false;
			    future.value = undefined;
			    args.push(function() {
			    	console.log("done");
			        future.done = true;
			        future.value = arguments;
			        resourcesLoaded += 1;
			    });
			    console.log(args);
			    callback.apply(args);
			    console.log("done");
			    return future;
			}*/
		</script>
        
        <script>
            //add sounds
            var sounds = {
                ground1: new Howl({src: ["sounds/Team8a_DamageWithGround.wav"]}),
                ground2: new Howl({src: ["sounds/Team8a_DamageWithGround02.wav"]}),
                ground3: new Howl({src: ["sounds/Team8a_DamageWithGround03.wav"]}),
                explosion: new Howl({src: ["sounds/Team8a_Explosion.wav"]}),
                engine: new Howl({src: ["sounds/Team8a_PlaneEngine_Loop.wav"],
                                 loop: true}),
                shoot1: new Howl({src: ["sounds/Team8a_Shoot.wav"]}),
                shoot2: new Howl({src: ["sounds/Team8a_Shoot_var_01.wav"]})
            };
        </script>
        <script>

        </script>   

		<script src="terrain.js"></script>
		<script src="input.js"></script>
		<script src="player.js"></script>

		<script>
			function alignAlongVector(mesh, vec) {
				var dir = vec.clone();
				dir.normalize();
				var worldUp = new THREE.Vector3(0, 1, 0);

				var right = new THREE.Vector3();
				right.crossVectors(dir, worldUp);

				var up = new THREE.Vector3();
				up.crossVectors(dir, right);

				var rotMat = new THREE.Matrix4().makeBasis(right, up, dir);
				var rotQuat = new THREE.Quaternion().setFromRotationMatrix(rotMat);
				rotQuat.normalize();

				mesh.setRotationFromQuaternion(rotQuat);

				return rotMat;
			}

			function spawnBullet(position, direction, material, stand) {            
				var bullet = new Object();
				bullet.lifetime = 500.0;
				bullet.velocity = direction.clone();
				bullet.velocity.normalize();
				if (stand == true) {
					bullet.velocity.set(0, 0, 0);
				}
				bullet.velocity.multiplyScalar(50000.0);
				bullet.mesh = new THREE.Mesh(bulletGeometry, material);
				scene.add(bullet.mesh);
				bullet.mesh.castShadow = true;
				bullet.mesh.position.copy(position);
				alignAlongVector(bullet.mesh, direction);
				bullet.alive = true;
				bullets[nextBulletIndex] = bullet;
				nextBulletIndex++;
				if(nextBulletIndex >= maxBullets) nextBulletIndex = 0;
			}

			function updateBullets(dt) {
				for (var i = 0; i < maxBullets; ++i) {
					var bullet = bullets[i];
					if (bullet != undefined && bullet.alive) {
						bullet.lifetime -= dt;
						if (bullet.lifetime <= 0) {
							bullet.alive = false;
							scene.remove(bullet.mesh);
						} else {
							var deltaPos = bullet.velocity.clone();
							deltaPos.multiplyScalar(dt);
							bullet.mesh.position.add(deltaPos);

							// check collisions
						}
					}
				}
			}

			function lerp(a, b, t) {
				return a * (1 - t) + b * t;
			}

			init();
			animate();

			function init() {                
				container = document.getElementById( 'container' );

				scene = new THREE.Scene();

				terrain = new Terrain(30000, 30000, worldWidth - 1, worldDepth - 1);
				scene.add(terrain.mesh);
                
                //console.log(gamepads);
				//pad = navigator.getGamepads()[1];


				/*var player = new Player(1, 1, 0, new KeyboardController());
				player.mesh.position.set(1000, 0, 0);
				player.mesh.position.y = terrain.getHeight(player.mesh.position.x, player.mesh.position.z) + 100;
				players.push(player);
				scene.add(player.mesh);*/


				var player = new Player(1, 4, 0, new KeyboardController());
				player.mesh.position.set(1000, 0, 0);
				player.mesh.position.y = terrain.getHeight(player.mesh.position.x, player.mesh.position.z) + 100;
				players.push(player);
				scene.add(player.mesh);

				player = new Player(2, 4, 1, new KeyboardController());
				player.mesh.position.set(2000, 0, 0);
				player.mesh.position.y = terrain.getHeight(player.mesh.position.x, player.mesh.position.z) + 100;
				players.push(player);
				scene.add(player.mesh);

				player = new Player(3, 4, 2, new KeyboardController());
				player.mesh.position.set(-1000, 0, 0);
				player.mesh.position.y = terrain.getHeight(player.mesh.position.x, player.mesh.position.z) + 100;
				players.push(player);
				scene.add(player.mesh);

				player = new Player(4, 4, 3, new KeyboardController());
				player.mesh.position.set(-2000, 0, 0);
				player.mesh.position.y = terrain.getHeight(player.mesh.position.x, player.mesh.position.z) + 100;
				players.push(player);
				scene.add(player.mesh);
                
                skybox = new THREE.Mesh

				light = new THREE.DirectionalLight(0xffe0b3);
				light.castShadow = true;
				var shadowVolumeSize = 4000;
				light.shadow.camera.near = 10;
				light.shadow.camera.far = 20000;
				light.shadow.camera.left = -shadowVolumeSize;
				light.shadow.camera.right = shadowVolumeSize;
				light.shadow.camera.top = shadowVolumeSize;
				light.shadow.camera.bottom = -shadowVolumeSize;
				light.shadow.mapWidth = 8192;
				light.shadow.mapHeight = 8192;
				scene.add(light);

				//scene.add(new THREE.CameraHelper(light.shadow.camera));

				renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;

				renderer.shadowMap.enabled = true;
				renderer.shadowMapSoft = true;

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );

				initialized = true;
			}

			function onWindowResize() {
				for(var i = 0; i < players.length; ++i) {
					// TODO: fix this
					players[i].camera.aspect = window.innerWidth / window.innerHeight;
					players[i].camera.updateProjectionMatrix();
					players[i].hudCamera.updateProjectionMatrix();
				}

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame(animate);

				/*if(resourcesToLoad == resourcesLoaded) {
					console.log("init");
					init();
				}*/

				//if(initialized) {
					var dt = clock.getDelta();

					updateBullets(dt);
					for(var i = 0; i < players.length; ++i) {
						players[i].update(dt);
					}

					render();
					stats.update();
				//}
			}

			function render() {
				renderer.clear();
				var size = renderer.getSize();

				renderer.setScissorTest(true);
				for(var i = 0; i < players.length; ++i) {
					var vp = players[i].viewport;
					//renderer.setScissor(vp.x, vp.y, vp.width, vp.height);
					renderer.setViewport(vp.x, vp.y, vp.width, vp.height);
					renderer.render(scene, players[i].camera);
					renderer.render(players[i].hudScene, players[i].hudCamera);
				}
				renderer.setScissorTest(false);

				renderer.setScissor(0, 0, size.width, size.height);
				renderer.setViewport(0, 0, size.width, size.height);
			}

		</script>

	</body>
</html>
