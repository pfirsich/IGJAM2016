<!DOCTYPE html>
<html lang="en">
	<head>
		<title>sadness</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

		<script src="three.js"></script>

		<script src="js/controls/FirstPersonControls.js"></script>

		<script src="js/ImprovedNoise.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/threex.keyboardstate.js"></script>

		<script>

			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;

			var camera, controls, scene, renderer, player;

			var mesh, texture;

			var worldWidth = 256, worldDepth = 256,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var clock = new THREE.Clock();

			var keyboard = new THREEx.KeyboardState();

			function Terrain(width, height, widthSegments, heightSegments) {
				this.width = width;
				this.height = height;
				this.widthSegments = widthSegments;
				this.heightSegments = heightSegments;
				this.dataToUnitConversion = 5;

				this.data = this.generateHeight(widthSegments + 1, heightSegments + 1);

				this.geometry = new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments);
				this.geometry.rotateX( - Math.PI / 2 );
				var vertices = this.geometry.attributes.position.array;
				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
					vertices[j + 1] = this.data[i] * this.dataToUnitConversion;
				}

				this.texture = new THREE.CanvasTexture( this.generateTexture( this.data, worldWidth, worldDepth ) );
				this.texture.wrapS = THREE.ClampToEdgeWrapping;
				this.texture.wrapT = THREE.ClampToEdgeWrapping;

				this.mesh = new THREE.Mesh( this.geometry, new THREE.MeshBasicMaterial( { map: this.texture } ) );
			}

			Terrain.prototype.generateHeight = function(width, height) {
				var size = width * height, data = new Uint8Array( size ),
				perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

				for ( var j = 0; j < 4; j ++ ) {

					for ( var i = 0; i < size; i ++ ) {

						var x = i % width, y = ~~ ( i / width );
						data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );

					}

					quality *= 5;

				}

				return data;
			}

			Terrain.prototype.generateTexture = function(data, width, height) {
				var canvas, canvasScaled, context, image, imageData,
				level, diff, vector3, sun, shade;

				vector3 = new THREE.Vector3( 0, 0, 0 );

				sun = new THREE.Vector3( 1, 1, 1 );
				sun.normalize();

				canvas = document.createElement( 'canvas' );
				canvas.width = width;
				canvas.height = height;

				context = canvas.getContext( '2d' );
				context.fillStyle = '#000';
				context.fillRect( 0, 0, width, height );

				image = context.getImageData( 0, 0, canvas.width, canvas.height );
				imageData = image.data;

				for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

					vector3.x = data[ j - 2 ] - data[ j + 2 ];
					vector3.y = 2;
					vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
					vector3.normalize();

					shade = vector3.dot( sun );

					imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );
					imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
					imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
				}

				context.putImageData( image, 0, 0 );

				// Scaled 4x

				canvasScaled = document.createElement( 'canvas' );
				canvasScaled.width = width * 4;
				canvasScaled.height = height * 4;

				context = canvasScaled.getContext( '2d' );
				context.scale( 4, 4 );
				context.drawImage( canvas, 0, 0 );

				image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
				imageData = image.data;

				for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

					var v = ~~ ( Math.random() * 5 );

					imageData[ i ] += v;
					imageData[ i + 1 ] += v;
					imageData[ i + 2 ] += v;

				}

				context.putImageData( image, 0, 0 );

				return canvasScaled;
			}

			Terrain.prototype.getHeight = function(x, y) {
				// half is center
				var x = worldHalfWidth + Math.floor(x / this.width * this.widthSegments);
				x = Math.min(Math.max(x, 0), this.widthSegments);
				var y = worldHalfDepth + Math.floor(y / this.height * this.heightSegments);
				y = Math.min(Math.max(y, 0), this.heightSegments);
				return this.data[x + y * worldWidth] * this.dataToUnitConversion;
			}

			function Input(stateCallback) {
				this.stateCallback = stateCallback;
				this.state = 0;
			}

			Input.prototype.update = function() {
				this.lastState = this.state;
				this.state = this.stateCallback();
				this.pressed = this.state > this.lastState;
				this.released = this.state < this.lastState;
			}

			Input.getAxisInputFromKeyboard = function(positive, negative) {
				return new Input(function() {return (keyboard.pressed(positive) ? 1.0 : 0.0) - (keyboard.pressed(negative) ? 1.0 : 0.0)});
			}

			function KeyboardController(left, right, up, down) {
				this.moveX = Input.getAxisInputFromKeyboard(left, right);
				this.moveY = Input.getAxisInputFromKeyboard(up, down);
			}

			KeyboardController.prototype.update = function() {
				this.moveX.update();
				this.moveY.update();
			}

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );

				scene = new THREE.Scene();

				var terrain = new Terrain(20000, 20000, worldWidth - 1, worldDepth - 1);
				scene.add(terrain.mesh);

				player = new Object();

				player.geometry = new THREE.BoxGeometry(200, 200, 200);
				player.material = new THREE.MeshPhongMaterial( {
					color: 0x156289,
					emissive: 0x072534,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				} );
				player.mesh = new THREE.Mesh(player.geometry, player.material);
				player.velocity = new THREE.Vector3(0.0, 0.0, -1.0)
				player.speed = 1000.0;
				player.accel = 1000.0;
				player.cameraDistance = 1000.0;
				player.velocity.multiplyScalar(player.speed);
				scene.add(player.mesh);

				player.controller = new KeyboardController("left", "right", "up", "down");

				player.mesh.position.y = terrain.getHeight(0, 0) + 100;

				camera.position.x = 0;
				camera.position.z = 1000;
				camera.position.y = terrain.getHeight(camera.position.x, camera.position.z) + 500;
				camera.lookAt(player.mesh.position);

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function updatePlayer(dt) {
				player.controller.update();

				var move = new THREE.Vector3(-player.controller.moveX.state, -player.controller.moveY.state, 0);
				move.multiplyScalar(player.accel);
				move.multiplyScalar(dt);

				var direction = player.velocity.clone();
				direction.normalize();

				player.right = new THREE.Vector3();
				player.right.crossVectors(direction, new THREE.Vector3(0, 1, 0));

				player.up = new THREE.Vector3();
				player.up.crossVectors(direction, player.right);

				var rotMat = new THREE.Matrix4().makeBasis(player.right, player.up, direction);
				player.mesh.quaternion = new THREE.Quaternion().setFromRotationMatrix(rotMat);
				move.applyMatrix4(rotMat);

				player.velocity.add(move);
				player.velocity.setLength(player.speed);

				var velDt = player.velocity.clone();
				velDt.multiplyScalar(dt);
				player.mesh.position = player.mesh.position.add(velDt);
			}

			function updateCamera(dt) {
				var playerPos = player.mesh.position.clone();
				var rel = playerPos.sub(camera.position);
				rel.setLength(Math.max(rel.length() - player.cameraDistance, 0));
				camera.position.add(rel);
				camera.lookAt(player.mesh.position);
			}

			function animate() {
				requestAnimationFrame(animate);

				var dt = clock.getDelta();

				updatePlayer(dt);
				updateCamera(dt);

				render();
				stats.update();
			}

			function render() {
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>
