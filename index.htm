<!DOCTYPE html>
<html lang="en">
	<head>
		<title>sadness</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

		<script src="three.js"></script>

		<script src="js/ImprovedNoise.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="js/threex.keyboardstate.js"></script>

		<script>

			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;

			var camera, controls, scene, renderer;

			var player;
			var maxBullets = 250, nextBulletIndex = 0, bullets = new Array(maxBullets);
			var bulletGeometry = new THREE.BoxGeometry(40, 40, 100);
			var bulletMaterial = new THREE.MeshPhongMaterial( {
					color: 0xffff00,
					emissive: 0xffff00,
					shading: THREE.FlatShading
				} );

			var terrain, light;

			var worldWidth = 256, worldDepth = 256,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var clock = new THREE.Clock();

			var keyboard = new THREEx.KeyboardState();

			var sunDir = new THREE.Vector3(0.4, 1, 0.4);
			sunDir.normalize();

			function Terrain(width, height, widthSegments, heightSegments) {
				this.width = width;
				this.height = height;
				this.widthSegments = widthSegments;
				this.heightSegments = heightSegments;
				this.dataToUnitConversion = 10;

				this.data = this.generateHeight(widthSegments + 1, heightSegments + 1);

				this.geometry = new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments);
				this.geometry.rotateX( - Math.PI / 2 );
				var vertices = this.geometry.attributes.position.array;
				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
					vertices[j + 1] = this.data[i] * this.dataToUnitConversion;
				}
				this.geometry.computeFaceNormals();
				this.geometry.computeVertexNormals();

				this.texture = new THREE.CanvasTexture( this.generateTexture( this.data, worldWidth, worldDepth ) );
				this.texture.wrapS = THREE.ClampToEdgeWrapping;
				this.texture.wrapT = THREE.ClampToEdgeWrapping;

				//this.material = new THREE.MeshBasicMaterial( { map: this.texture } );
				this.material = new THREE.MeshLambertMaterial({
					color: 0xe68a00,
					shading: THREE.SmoothShading
				});
				this.mesh = new THREE.Mesh(this.geometry, this.material);
				this.mesh.castShadow = true;
				this.mesh.receiveShadow = true;
			}

			Terrain.prototype.generateHeight = function(width, height) {
				var size = width * height, data = new Uint8Array( size ),
				perlin = new ImprovedNoise(), quality = 50, z = Math.random() * 100;

				for ( var j = 0; j < 1; j ++ ) {
					for ( var i = 0; i < size; i ++ ) {
						var x = i % width, y = ~~ ( i / width );
						data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 10.75 );
					}
					quality *= 5;
				}

				return data;
			}

			Terrain.prototype.generateTexture = function(data, width, height) {
				var canvas, canvasScaled, context, image, imageData,
				level, diff, vector3, sun, shade;

				vector3 = new THREE.Vector3( 0, 0, 0 );

				sun = new THREE.Vector3( 1, 1, 1 );
				sun.normalize();

				canvas = document.createElement( 'canvas' );
				canvas.width = width;
				canvas.height = height;

				context = canvas.getContext( '2d' );
				context.fillStyle = '#000';
				context.fillRect( 0, 0, width, height );

				image = context.getImageData( 0, 0, canvas.width, canvas.height );
				imageData = image.data;

				for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

					vector3.x = data[ j - 2 ] - data[ j + 2 ];
					vector3.y = 2;
					vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
					vector3.normalize();

					shade = vector3.dot( sun );

					imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );
					imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
					imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
				}

				context.putImageData( image, 0, 0 );

				// Scaled 4x

				canvasScaled = document.createElement( 'canvas' );
				canvasScaled.width = width * 4;
				canvasScaled.height = height * 4;

				context = canvasScaled.getContext( '2d' );
				context.scale( 4, 4 );
				context.drawImage( canvas, 0, 0 );

				image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
				imageData = image.data;

				for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

					var v = ~~ ( Math.random() * 5 );

					imageData[ i ] += v;
					imageData[ i + 1 ] += v;
					imageData[ i + 2 ] += v;

				}

				context.putImageData( image, 0, 0 );

				return canvasScaled;
			}

			Terrain.prototype.getHeight = function(x, y) {
				// half is center
				var x = worldHalfWidth + Math.floor(x / this.width * this.widthSegments);
				x = Math.min(Math.max(x, 0), this.widthSegments);
				var y = worldHalfDepth + Math.floor(y / this.height * this.heightSegments);
				y = Math.min(Math.max(y, 0), this.heightSegments);
				return this.data[x + y * worldWidth] * this.dataToUnitConversion;
			}

			function Input(stateCallback) {
				this.stateCallback = stateCallback;
				this.state = 0;
			}

			Input.prototype.update = function() {
				this.lastState = this.state;
				this.state = this.stateCallback();
				this.pressed = this.state > this.lastState;
				this.released = this.state < this.lastState;
			}

			Input.getAxisInputFromKeyboard = function(positive, negative) {
				return new Input(function() {return (keyboard.pressed(positive) ? 1.0 : 0.0) - (keyboard.pressed(negative) ? 1.0 : 0.0)});
			}

			function KeyboardController(left, right, up, down) {
				this.moveX = Input.getAxisInputFromKeyboard(left, right);
				this.moveY = Input.getAxisInputFromKeyboard(up, down);
				this.shoot = new Input(function() {return keyboard.pressed("a") ? 1.0 : 0.0});
			}

			KeyboardController.prototype.update = function() {
				this.moveX.update();
				this.moveY.update();
				this.shoot.update();
			}

			function alignAlongVector(mesh, vec) {
				var dir = vec.clone();
				dir.normalize();
				var worldUp = new THREE.Vector3(0, 1, 0);

				var right = new THREE.Vector3();
				right.crossVectors(dir, worldUp);

				var up = new THREE.Vector3();
				up.crossVectors(dir, right);

				var rotMat = new THREE.Matrix4().makeBasis(right, up, dir);
				var rotQuat = new THREE.Quaternion().setFromRotationMatrix(rotMat);
				rotQuat.normalize();

				mesh.setRotationFromQuaternion(rotQuat);

				return rotMat;
			}

			function spawnBullet(position, direction) {
				var bullet = new Object();
				bullet.lifetime = 5.0;
				bullet.velocity = direction.clone();
				bullet.velocity.normalize();
				bullet.velocity.set(0, 0, 0);
				bullet.velocity.multiplyScalar(30000.0);
				bullet.mesh = new THREE.Mesh(bulletGeometry, bulletMaterial);
				scene.add(bullet.mesh);
				bullet.mesh.castShadow = true;
				bullet.mesh.position.copy(position);
				alignAlongVector(bullet.mesh, direction);
				bullet.alive = true;
				bullets[nextBulletIndex] = bullet;
				nextBulletIndex++;
				if(nextBulletIndex >= maxBullets) nextBulletIndex = 0;
			}

			function updateBullets(dt) {
				for (var i = 0; i < maxBullets; ++i) {
					var bullet = bullets[i];
					if (bullet != undefined && bullet.alive) {
						bullet.lifetime -= dt;
						if (bullet.lifetime <= 0) {
							bullet.alive = false;
							scene.remove(bullet.mesh);
						} else {
							var deltaPos = bullet.velocity.clone();
							deltaPos.multiplyScalar(dt);
							bullet.mesh.position.add(deltaPos);

							// check collisions
						}
					}
				}
			}

			init();
			animate();

			function init() {
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );

				scene = new THREE.Scene();

				terrain = new Terrain(30000, 30000, worldWidth - 1, worldDepth - 1);
				scene.add(terrain.mesh);

				player = new Object();

				player.geometry = new THREE.BoxGeometry(200, 200, 200);
				player.material = new THREE.MeshPhongMaterial( {
					color: 0x156289,
					emissive: 0x072534,
					side: THREE.DoubleSide,
					shading: THREE.FlatShading
				} );
				player.mesh = new THREE.Mesh(player.geometry, player.material);
				player.mesh.castShadow = true;
				player.mesh.receiveShadow = true;
				player.velocity = new THREE.Vector3(0.0, 0.0, -1.0);
				player.speed = 2000.0;
				player.accel = player.speed;
				player.cameraMinDistance = 50.0;
				player.cameraDistance = 1000.0;
				player.cameraApproachSpeed = 1.0;
				player.focusPointDistance = player.speed;
				player.focusPointMaxDistance = player.speed * 5.0;
				player.velocity.multiplyScalar(player.speed);
				player.nextShot = clock.getElapsedTime();
				player.shotInterval = 0.15;
				player.radius = 100.0;
				scene.add(player.mesh);

				player.controller = new KeyboardController("left", "right", "up", "down");

				player.mesh.position.y = terrain.getHeight(0, 0) + 100;

				light = new THREE.DirectionalLight(0xffe0b3);
				light.castShadow = true;
				var shadowVolumeSize = 2000;
				light.shadow.camera.near = 10;
				light.shadow.camera.far = 20000;
				light.shadow.camera.left = -shadowVolumeSize;
				light.shadow.camera.right = shadowVolumeSize;
				light.shadow.camera.top = shadowVolumeSize;
				light.shadow.camera.bottom = -shadowVolumeSize;
				light.shadow.mapWidth = 8192;
				light.shadow.mapHeight = 8192;
				scene.add(light);

				scene.add(new THREE.CameraHelper(light.shadow.camera));

				camera.position.x = 0;
				camera.position.z = 1000;
				camera.position.y = terrain.getHeight(camera.position.x, camera.position.z) + 500;
				camera.lookAt(player.mesh.position);
				camera.terrainOffset = 60;

				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.shadowMap.enabled = true;
				renderer.shadowMapSoft = true;

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				stats = new Stats();
				container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function updatePlayer(dt) {
				player.controller.update();

				var rotMat = alignAlongVector(player.mesh, player.velocity);

				var move = new THREE.Vector3(-player.controller.moveX.state, -player.controller.moveY.state, 0);
				move.multiplyScalar(player.accel);
				move.multiplyScalar(dt);
				move.applyMatrix4(rotMat);

				var terrainHeight = terrain.getHeight(player.mesh.position.x, player.mesh.position.z);
				if (player.mesh.position.y < terrainHeight) {
					player.mesh.position.setY(terrainHeight);
					player.velocity.add(new THREE.Vector3(0, 200, 0));
				}

				player.velocity.add(move);
				player.velocity.setLength(player.speed);

				var velDt = player.velocity.clone();
				velDt.multiplyScalar(dt);
				player.mesh.position = player.mesh.position.add(velDt);

				if (player.controller.shoot.state > 0 || true) {
					if (player.nextShot < clock.getElapsedTime()) {
						player.nextShot = clock.getElapsedTime() + player.shotInterval;
						spawnBullet(player.mesh.position, player.velocity);
					}
				}
			}

			function lerp(a, b, t) {
				return a * (1 - t) + b * t;
			}

			function updateCamera(dt) {
				var playerVelocity = player.velocity.clone();
				playerVelocity.normalize();
				var angleDist = Math.max(0, camera.getWorldDirection().dot(playerVelocity));

				var playerPos = player.mesh.position.clone();
				var rel = playerPos.sub(camera.position);
				var targetDistance = lerp(player.cameraMinDistance, player.cameraDistance, angleDist);
				rel.setLength((rel.length() - targetDistance));
				camera.position.add(rel);

				var terrainHeight = terrain.getHeight(camera.position.x, camera.position.z);
				if (camera.position.y < terrainHeight) {
					camera.position.y = terrainHeight + camera.terrainOffset;
				}

				var focusPoint = player.velocity.clone();
				focusPoint.setLength(lerp(player.focusPointMaxDistance, player.focusPointDistance, angleDist));
				focusPoint.add(player.mesh.position);
				camera.lookAt(focusPoint);

				light.target = camera;
				console.log(light.target.position);
				var dir = sunDir.clone();
				dir.multiplyScalar(5000.0);
				light.position.copy(dir.add(light.target.position));
			}

			function animate() {
				requestAnimationFrame(animate);

				var dt = clock.getDelta();

				updateBullets(dt);
				updatePlayer(dt);
				updateCamera(dt);

				render();
				stats.update();
			}

			function render() {
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>
